---
import PostLayout from '../../layouts/PostLayout.astro';
import { getCollection } from 'astro:content';

export async function getStaticPaths() {
  const posts = await getCollection('posts');
  return posts.map((post) => ({
    params: { slug: post.slug },
    props: { post, allPosts: posts },
  }));
}

const { post, allPosts } = Astro.props;
const { Content } = await post.render();

const bodyText = post.body.replace(/<[^>]+>/g, '').replace(/&[a-z]+;/gi, ' ').replace(/\s+/g, ' ').trim();
const readingTime = Math.max(1, Math.round(bodyText.length / 500));

const myTags = post.data.tags ?? [];

// 전체 태그에서 공통 루트 키워드를 자동 추출
function buildRootKeywords(allPosts: any[]): string[] {
  const tagSet = new Set<string>();
  for (const p of allPosts) {
    for (const t of (p.data.tags ?? [])) tagSet.add(t);
  }
  const allTags = [...tagSet];

  const freq = new Map<string, number>();
  for (const tag of allTags) {
    for (const other of allTags) {
      if (tag === other) continue;
      // tag가 other의 부분 문자열이고 2글자 이상이면 루트 후보
      if (tag.length >= 2 && tag.length <= 6 && other.includes(tag)) {
        freq.set(tag, (freq.get(tag) ?? 0) + 1);
      }
      // 공통 접두사 추출 (2~6글자)
      let common = 0;
      while (common < tag.length && common < other.length && tag[common] === other[common]) common++;
      if (common >= 2 && common <= 6) {
        const prefix = tag.slice(0, common);
        freq.set(prefix, (freq.get(prefix) ?? 0) + 1);
      }
    }
  }

  return [...freq.entries()]
    .filter(([kw, cnt]) => cnt >= 2 && kw.length >= 2)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 150)
    .map(([kw]) => kw);
}

const autoKeywords = buildRootKeywords(allPosts);

function getKeywords(tags: string[]): string[] {
  const roots = new Set<string>();
  for (const tag of tags) {
    for (const kw of autoKeywords) {
      if (tag.includes(kw)) roots.add(kw);
    }
    roots.add(tag);
  }
  return [...roots];
}

const myKeywords = new Set(getKeywords(myTags));

const scored = allPosts
  .filter((p: any) => p.slug !== post.slug)
  .map((p: any) => {
    const otherKeywords = getKeywords(p.data.tags ?? []);
    let score = 0;
    for (const kw of otherKeywords) {
      if (myKeywords.has(kw)) score += 1;
    }
    return { ...p, score };
  })
  .filter((p: any) => p.score > 0)
  .sort((a: any, b: any) => b.score - a.score || (b.data.date?.valueOf() ?? 0) - (a.data.date?.valueOf() ?? 0))
  .slice(0, 3);

function getExcerpt(body: string, maxLen = 80): string {
  const text = body.replace(/<[^>]+>/g, '').replace(/&[a-z]+;/gi, ' ').replace(/\s+/g, ' ').trim();
  if (text.length <= maxLen) return text;
  return text.slice(0, maxLen).replace(/\s\S*$/, '') + '…';
}

function getReadTime(body: string): number {
  const text = body.replace(/<[^>]+>/g, '').replace(/&[a-z]+;/gi, ' ').replace(/\s+/g, ' ').trim();
  return Math.max(1, Math.round(text.length / 500));
}

const relatedPosts = scored.map((p: any) => ({
  slug: p.slug,
  title: p.data.title,
  image: p.data.image?.path ?? null,
  date: p.data.date,
  category: p.data.categories?.[0] ?? null,
  excerpt: getExcerpt(p.body),
  readingTime: getReadTime(p.body),
}));

const sorted = [...allPosts].sort(
  (a: any, b: any) => (a.data.date?.valueOf() ?? 0) - (b.data.date?.valueOf() ?? 0)
);
const currentIdx = sorted.findIndex((p: any) => p.slug === post.slug);
const prevPost = currentIdx > 0 ? { slug: sorted[currentIdx - 1].slug, title: sorted[currentIdx - 1].data.title } : null;
const nextPost = currentIdx < sorted.length - 1 ? { slug: sorted[currentIdx + 1].slug, title: sorted[currentIdx + 1].data.title } : null;

const postTitle = post.data.title ?? '';
const postDesc = post.data.description ?? '';
const faqSchema = postTitle.includes('?') ? [{ question: postTitle, answer: postDesc }] : undefined;
---

<PostLayout
  title={post.data.title}
  description={post.data.description}
  date={post.data.date}
  image={post.data.image?.path}
  tags={post.data.tags}
  relatedPosts={relatedPosts}
  readingTime={readingTime}
  prevPost={prevPost}
  nextPost={nextPost}
  faqSchema={faqSchema}
>
  <Content />
</PostLayout>
